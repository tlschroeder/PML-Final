x = data(mtcars)
lm(mtcars$weight ~ mtcars$mpg)
View(mtcars)
lm(mtcars$wt ~ mtcars$mpg)
coef(lm(mtcars$wt ~ mtcars$mpg))
x <- c(0.8, 0.47, 0.51, 0.73, 0.36, 0.58, 0.57, 0.85, 0.44, 0.42)
y <- c(1.39, 0.72, 1.55, 0.48, 1.19, -1.59, 1.23, -0.65, 1.49, 0.05)
xc = x-mean(x)
yx = y-mean(y)
lm(xc, yx - 1)
lm(xc ~ yx - 1)
coef(lm(mtcars$wt ~ mtcars$mpg))
lm(xc ~ yx)
lm(x ~ y)
mean(c(0.8, 0.47, 0.51, 0.73, 0.36, 0.58, 0.57, 0.85, 0.44, 0.42))
coef(lm(formula mtcars$wt ~ mtcars$mpg, data = mtcars))
coef(lm(formula mtcars$wt ~ mtcars$mpg data = mtcars))
coef(lm(formula = mtcars$wt ~ mtcars$mpg, data = mtcars))
coef(lm(formula = mtcars$wt*1000 ~ mtcars$mpg, data = mtcars))
coef(lm(formula = mtcars$wt ~ mtcars$mpg, data = mtcars))
lm(formula = mtcars$wt ~ mtcars$mpg, data = mtcars)
lm(formula = mtcars$mpg ~ mtcars$wt, data = mtcars)
lm(y ~ x)
z <- c(8.58, 10.46, 9.01, 9.64, 8.86)
z = z - mean(z)
z <- c(8.58, 10.46, 9.01, 9.64, 8.86)
z2 = z - mean(z)
z2 = z2/sd(z)
lm(x ~ y)
lm(y ~ x)
a = coef(lm(y ~ x))/coef(lm(x ~ y))
a
a = -1.713/-0.04462
a
var(y)/var(x)
x <- c(0.8, 0.47, 0.51, 0.73, 0.36, 0.58, 0.57, 0.85, 0.44, 0.42)
y <- c(1.39, 0.72, 1.55, 0.48, 1.19, -1.59, 1.23, -0.65, 1.49, 0.05)
lm(y ~ x)
lm(y ~ 0 + x)
(2*0.18 + -1.54+ 3*0.42+.95)7
(2*0.18 + -1.54+ 3*0.42+.95)/7
x <- c(0.8, 0.47, 0.51, 0.73, 0.36, 0.58, 0.57, 0.85, 0.44, 0.42)
y <- c(1.39, 0.72, 1.55, 0.48, 1.19, -1.59, 1.23, -0.65, 1.49, 0.05)
lm(y ~ 0 + x)
lm(y ~ x)
mean(c(0.8, 0.47, 0.51, 0.73, 0.36, 0.58, 0.57, 0.85, 0.44, 0.42))
lm(mtcars$mpg ~ mtcars$wt)
install.packages(“RMySQL”, type = “source”)
install.packages("RMySQL")
library(RMySQL)
source("http://bioconductor.org/biocLite.r")
source("http://bioconductor.org/biocLite.R")
library(rhdf5)
biocLite("rhdf5")
library(rhdf5)
install.packages("httr")
library(httr)
html = GET("http://biostat.jhsph.edu/~jleek/contact.html")
c = content(html, as="text")
p = htmlParse(c, asText = TRUE)
library(XML)
p = htmlParse(c, asText = TRUE)
conec = url("http://biostat.jhsph.edu/~jleek/contact.html")
t = readLines(conec)
close(conec)
sapply(t[c(10, 20, 30, 100)], nchar)
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fwksst8110.for"
lines <- readLines(url, n=10)
w <- c(1, 9, 5, 4, 1, 3, 5, 4, 1, 3, 5, 4, 1, 3, 5, 4, 1, 3)
colNames <- c("filler", "week", "filler", "sstNino12", "filler", "sstaNino12", "filler", "sstNino3", "filler", "sstaNino3", "filler", "sstNino34", "filler", "sstaNino34", "filler", "sstNino4", "filler", "sstaNino4")
d <- read.fwf(url, w, header=FALSE, skip=4, col.names=colNames)
d <- d[, grep("^[^filler]", names(d))]
sum(d[, 4])
x <- c(0.61, 0.93, 0.83, 0.35, 0.54, 0.16, 0.91, 0.62, 0.62)
y <- c(0.67, 0.84, 0.6, 0.18, 0.85, 0.47, 1.1, 0.65, 0.36)
l = lm(y ~ x)
summary(l)
t.test(x,y)
data(mtcars)
l = lm(mtcars$mpg ~ mtcars$wt)
summary(l)
csum = summary(l)$coefficients
csum[2,1]+c(-1,1)*qt(.975,df=l$df)*csum[2,2]
predict(l, newdata = 3000, interval = "prediction")
predict(l, newdata = data.frame(3000), interval = "prediction")
predict(l, newdata = data.frame(wt=3000/1000), interval = "prediction")
l = lm(mtcars$mpg ~ mtcars$wt, data = mtcars)
predict(l, newdata = data.frame(wt=3000/1000), interval = "prediction")
newdata = data.frame(wt = 3000/1000)
predict(l, newdata, interval = "prediction")
fit <- lm(mpg ~ wt, data=mtcars)
newdata <- data.frame(wt=3000/1000)
predict(fit, newdata, interval=("prediction"))
predict(fit, newdata = mtcars$wt/2, interval=("prediction"))
y <- mtcars$mpg; x <- mtcars$wt
fitWithIntercept <- lm(y ~ x)
yhat1 <- fit$coefficients[1] + x
se1 <- sum((y - yhat1)^2)
yhat2 <- fit$coefficients[1] + fit$coefficients[2] * x
se2 <- sum((y - yhat2)^2)
ratio <- se2 / se1
ratio
y <- mtcars$mpg; x <- mtcars$wt; n <- length(y)
fit <- lm(y ~ x - 1)
beta1 <- summary(fit)$coefficients[1]
e <- y - beta1*x
sse1 <- sum(e^2)
# to the model with the intercept and slope (numerator)?
y <- mtcars$mpg; x <- mtcars$wt; n <- length(y)
beta1 <- cor(y, x) * sd(y) / sd(x)
beta0 <- mean(y) - beta1 * mean(x)
e <- y - beta0 - beta1 * x
sse2 <- sum(e^2)
# this is not what the question asked for (it asked for sse2/sse1)
# but hey, it worked
sqrt(sse2)/sqrt(sse1)
data(mtcars)
lm(mpg ~ wt, data = mtcars)
lm(mpg ~ factor(cyl) + wt, data = mtcars)
lm(mpg ~ as.factor(cyl), data = mtcars)
install.packages("ElemStatLearn")
install.packages("pgmm")
install.packages("rpart")
library(AppliedPredictiveModeling)
data(segmentationOriginal)
library(caret)
library(MASS)
data(?shuttle)
data(shuttle)
x = shuttle
View(shuttle)
View(x)
View(mtcars)
library(caret)
test = read.csv("pml-testing.csv")
train = read.csv("pml-training.csv")
ncol(train)
nrow(train)
nrow(test)
setwd("~/GitHub/PML-Final")
test = read.csv("pml-testing.csv")
train = read.csv("pml-training.csv")
ncol(train)
nrow(train)
nrow(test)
cutcol = nearZeroVar(train, saveMetrics = TRUE)
train = train[,cutcol$nzv == FALSE]
test = test[,cutcol$nzv == FALSE]
train$X = NULL
test$X = NULL
train = train[,colMeans(is.na(train)) == 0]
test = test[,colMeans(is.na(test)) == 0]
test = test[,colMeans(is.na(test)) == 0]
set.seed = 1
split = createDataPartition(train$classe, p = 0.7, list = FALSE)
crosstrain = train[split,]
crossval = train[-split,]
library(randomForest)
forest = randomForest(classe ~ ., data=crosstrain, method="class")
crosspred = predict(forest, crossval, type = "class")
confusionMatrix(crosspred, crossval$classe)
predict(forest, newdata = test, type = "class")
test$problem_id = NULL
predict(forest, newdata = test, type = "class")
sapply(test, type)
sapply(type, test)
sapply(test, class)
sapply(train, class)
test = read.csv("pml-testing.csv")
test = test[,cutcol$nzv == FALSE]
test$X = NULL
test = test[,colMeans(is.na(test)) == 0]
predict(forest, newdata = test, type = "class")
sapply(test, class)
View(test)
View(train)
